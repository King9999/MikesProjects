<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//control variables to prevent redrawing certain sprites once they're on screen.
levelArray = 0;

//ensure that level always begins un-inverted
global.levelInverted = false;

global.keyTotal = 0;    //# of keys in level.
global.keyCount = 0;    //keys in player's possession.

//level display timer.
alarm[0] = 60;
xPos = -160;
placement = 4;
displayOff = false; //if true, removes level display from the screen.


for (var i = 0; i &lt; ds_grid_width(global.mapGrid); i++)
{
    for (var j = 0; j &lt; ds_grid_height(global.mapGrid); j++)
    {
        //ds_grid_set(levelGrid, i, j, ds_grid_get(global.mapGrid, i, j));
       // ds_grid_set(invLevelGrid, i, j, ds_grid_get(global.inverseGrid, i, j));
        
        //set the tile array
        switch(ds_grid_get(global.mapGrid, i, j))
        {
            case TILE_FORE:
                levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, tile1Obj);
                break;
                
            case TILE_BACK:
                levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, tile2Obj);
                break;
                
            case TILE_PLAYER:
                levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, playerObj);
                break;
                
            case TILE_EXIT:
                levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, exitObj);
                break;
                
            case TILE_KEY:
                levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, keyObj);
                global.keyTotal++;
                break;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!displayOff)
{
    if (alarm[0] &lt;= 0)
    {
        displayOff = true;
        placement = -4;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//slide the level display.
xPos += placement;

if (!displayOff)
{
    if (xPos &gt;= view_wview / 10)
    {
        xPos = view_wview / 10;
        placement = 0;
        alarm[0]--;
        show_debug_message("alarm 0 = " + string(alarm[0]));       
    }
}
else    //take level display off the screen.
{
    if (xPos &gt; -160)
        xPos += placement;
}

//check gamepad 
if (gamepad_button_check_pressed(0, gp_select))
{
    room_goto(levelLoader);
}

if (gamepad_button_check_pressed(0, gp_start))
{
    room_goto(menuScreen);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ds_exists(global.mapGrid, ds_type_grid))
{
    ds_grid_destroy(global.mapGrid);
    ds_grid_destroy(global.inverseGrid);
    show_debug_message("mapGrid destroyed.");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ds_exists(global.mapGrid, ds_type_grid))
{
    ds_grid_destroy(global.mapGrid);
    ds_grid_destroy(global.inverseGrid);
    show_debug_message("mapGrid destroyed.");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* At the start of each level, briefly display which level the player is on. */
draw_set_font(gameFont);
draw_set_color(c_white);
draw_text(xPos, 700 - view_yview, "LEVEL " + string(global.currentLevel + 1));

if (global.levelInverted)
{
    draw_set_font(gameFont);
    draw_set_color(c_red);
    draw_text(864 , 700, "INVERTED");
}

//display keys if there are any to collect.
if (global.keyTotal &gt; 0)
{
    draw_set_font(gameFont);
    draw_set_color(c_navy);
    draw_text(view_wview / 2 , 0, "Keys " + string(global.keyCount) + "/" + string(global.keyTotal));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* The level is drawn differently depending on whether it's inverted or not. */

//tile selection icons


if (!global.levelInverted)
{
    for (var i = 0; i &lt; ds_grid_width(global.mapGrid); i++)
    {
        for (var j = 0; j &lt; ds_grid_height(global.mapGrid); j++)
        {
           
            switch(ds_grid_get(global.mapGrid, i, j))
            {
                 case TILE_FORE:
                    with(levelArray[i, j])
                        instance_change(tile1Obj, 1);
                    break;
                 
                  case TILE_BACK:
                    with(levelArray[i, j])
                        instance_change(tile2Obj, 1);
                    break;
                  
                  case TILE_PLAYER:
                    with(levelArray[i, j])
                        instance_change(playerObj, 1);
                    break;
                    
                  case TILE_EXIT:
                    with(levelArray[i, j])
                        instance_change(exitObj, 1);
                    break;
                    
                   case TILE_KEY:
                    with(levelArray[i, j])
                        instance_change(keyObj, 1);
                    break;
            }
           
        }
    }
}
else
{
    for (var i = 0; i &lt; ds_grid_width(global.inverseGrid); i++)
    {
        for (var j = 0; j &lt; ds_grid_height(global.inverseGrid); j++)
        {
           
            switch(ds_grid_get(global.inverseGrid, i, j))
            {
                 case TILE_FORE:
                    with(levelArray[ds_grid_width(global.inverseGrid) - 1 - i, j])
                        instance_change(tile2Obj, 1);
                    break;
                 
                  case TILE_BACK:
                    with(levelArray[ds_grid_width(global.inverseGrid) - 1 - i, j])
                        instance_change(tile1Obj, 1);
                    break;
                  
                  case TILE_PLAYER:
                    with(levelArray[ds_grid_width(global.inverseGrid) - 1 - i, ds_grid_height(global.inverseGrid) - 1 - j])  //this is so the mirror is placed in the same position as player.
                        instance_change(playerObj, 1);
                    break;
                  
                  case TILE_EXIT:
                    with(levelArray[ds_grid_width(global.inverseGrid) - 1 - i, j])
                        instance_change(exitObj, 1);
                    break;
                    
                   case TILE_KEY:
                    with(levelArray[ds_grid_width(global.inverseGrid) - 1 - i, j])
                        instance_change(keyObj, 1);
                    break;
            }
           
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_goto(menuScreen);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
