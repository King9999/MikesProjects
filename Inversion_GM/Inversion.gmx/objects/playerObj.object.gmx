<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>player_right</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* set up player. The player has a "shadow" that's used to determine legal spots to invert. */

image_speed = 0;        //for now, no animation
startX = x;
startY = y;             //starting location for player.

//states
isJumping = false;
isDoubleJumping = false;
isRunning = false;
canInvert = false;//if true, then player's shadow is not obstructed.

//player movement

speedLimit = 0;//changes depending on whether player is running or walking
jumpHeight = 0;//must be a negative number
currentFriction = 0;//when it's 1, player can move normally.

//shadow
if (!global.shadowCreated)
{
    shadowInstance = instance_create(x, y + sprite_height, shadowObj);
    global.shadowCreated = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//gamepad check

if (global.padDetected)
{
    //movement (d-pad only)
    if (gamepad_button_check(0, gp_padl) || gamepad_axis_value(0, gp_axislh) &lt; -0.5)
    {
        sprite_index = player_left;
        image_speed = 0.3;
        hspeed -= 0.3;
        currentFriction = 1;
        if (hspeed &lt; -WALK_SPEED) hspeed = -WALK_SPEED;
    }
    
    
    if (gamepad_button_check(0, gp_padr) || gamepad_axis_value(0, gp_axislh) &gt; 0.5) //it appears the dead zone is large here.
    {
        sprite_index = player_right;
        image_speed = 0.3;
        hspeed += 0.3;
        currentFriction = 1;
        if (hspeed &gt; WALK_SPEED) hspeed = WALK_SPEED;
    }
    
    if (gamepad_button_check_released(0, gp_padl) || gamepad_button_check_released(0, gp_padr) || gamepad_axis_value(0, gp_axislh) == 0)
    {
        image_speed = 0;
        currentFriction = FRICTION;
    }
    
    //A button
    if (gamepad_button_check_pressed(0, gp_face1))
    {
        //jump
        if (!isJumping)
        {
            vspeed += JUMP_HEIGHT;
            isJumping = true;
            sound_play(jump);
        }
        else
        {
            if (!isDoubleJumping)
            {
                vspeed += JUMP_HEIGHT - vspeed;
                isDoubleJumping = true;
                sound_play(jump);
                show_debug_message("double jumping");
            }
        }
    }
    
    //B button
    if (gamepad_button_check_pressed(0, gp_face2))
    {
        if (!debug_mode)
        {
            if (!global.levelInverted)
            {
         
                   global.levelInverted = !global.levelInverted;
                   //the next line is what makes eveything work! grants the illusion that player swapped places with the shadow.        
                   y = -shadowObj.y - view_yview - sprite_height + ds_grid_height(global.mapGrid) * TILE_SIZE;
                   shadowObj.y = y + sprite_height;  
               
               
            }
            else
            {
               
                    global.levelInverted = !global.levelInverted;
                    y = -shadowObj.y - view_yview - sprite_height + ds_grid_height(global.inverseGrid) * TILE_SIZE;
                    
            }
        }
        else    //in debug mode, using different grids.
        {
            if (!global.levelInverted)
            {
               
                   global.levelInverted = !global.levelInverted;
                   //the next line is what makes eveything work! grants the illusion that player swapped places with the shadow.        
                   y = -shadowObj.y - view_yview - sprite_height + ds_grid_height(global.levelGrid) * TILE_SIZE;
                   //shadowObj.y = y + sprite_height;  
            
               
            }
            else
            {
                    global.levelInverted = !global.levelInverted;
                    y = -shadowObj.y - view_yview - sprite_height + ds_grid_height(global.invLevelGrid) * TILE_SIZE;
                    
            }
        }
    
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//apply friction
hspeed *= currentFriction;
if (abs(hspeed) &lt; 0.1)
{
    hspeed = 0;
}

//apply gravity
vspeed += GRAVITY;

if (vspeed &gt; DROP_SPEED)
{
    vspeed = DROP_SPEED;
}

//boundary check
if (x &lt; 0)
{
    x = 0;
}
if (x + sprite_width &gt; room_width)
{
    x = room_width - sprite_width;
}
if (y &gt; room_height)
{
    if (debug_mode)
    {
        x = startX;
        y = startY;
        shadowObj.x = x;
        shadowObj.y = y + sprite_height;
    }
    else
    {
        //restart level
        room_goto(levelLoader);
    }
    
}

//jump check

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>402</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_collision</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>-1</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>vspeed</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>vspeed = 0;
isJumping = false;
isDoubleJumping = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>402</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_collision</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>-1</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>hspeed</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hspeed = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="keyObj">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* Remove the key from both the normal and inverse level. Must get the location of the key
in the inverse level! */

/*var i = floor(x / TILE_SIZE);
var j = floor(y / TILE_SIZE);

if (debug_mode)
{
    with(ds_grid_get(global.levelGrid, i, j)
}*/

sound_play(keyPickup);
global.keyCount += 1;
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!global.padDetected)
{
    sprite_index = player_right;
    image_speed = 0.3;
    hspeed += 0.3;
    currentFriction = 1;
    if (hspeed &gt; WALK_SPEED) hspeed = WALK_SPEED;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!global.padDetected)
{
    sprite_index = player_left;
    image_speed = 0.3;
    hspeed -= 0.3;
    currentFriction = 1;
    if (hspeed &lt; -WALK_SPEED) hspeed = -WALK_SPEED;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//jump
if (!global.padDetected)
{
    if (!isJumping)
    {
        vspeed += JUMP_HEIGHT;
        isJumping = true;
        sound_play(jump);
    }
    else
    {
        if (!isDoubleJumping)
        {
            vspeed += JUMP_HEIGHT - vspeed;
            isDoubleJumping = true;
            sound_play(jump);
            show_debug_message("double jumping");
        }
    }
}


show_debug_message("isJumping = " + string(isJumping));
show_debug_message("isDJumping = " + string(isDoubleJumping));

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Invert the level if the player's shadow is in a legal position (i.e. not intersecting with a tile in the inverse level

//anytime the level inverts, double jumping is reset. The player can use this to reach high places.
//isDoubleJumping = false;

if (!global.padDetected)
{
    if (!debug_mode)
    {
        if (!global.levelInverted)
        {
     
               global.levelInverted = !global.levelInverted;
                /*the next line is what makes eveything work! grants the illusion that player swapped places with the shadow. */         
               y = -shadowObj.y - view_yview - sprite_height + ds_grid_height(global.mapGrid) * TILE_SIZE;
               shadowObj.y = y + sprite_height;  //this ensures that shadow ends up directly underneath player
           
           
        }
        else
        {
           
                global.levelInverted = !global.levelInverted;
                y = -shadowObj.y - view_yview - sprite_height + ds_grid_height(global.inverseGrid) * TILE_SIZE;
                //shadowObj.y = y + sprite_height;
                
        }
    }
    else    //in debug mode, using different grids.
    {
        if (!global.levelInverted)
        {
           
               global.levelInverted = !global.levelInverted;
                /*the next line is what makes eveything work! grants the illusion that player swapped places with the shadow. */         
               y = -shadowObj.y - view_yview - sprite_height + ds_grid_height(global.levelGrid) * TILE_SIZE;
               shadowObj.y = y + sprite_height;  
        
           
        }
        else
        {
                global.levelInverted = !global.levelInverted;
                y = -shadowObj.y - view_yview - sprite_height + ds_grid_height(global.invLevelGrid) * TILE_SIZE;
                
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!global.padDetected)
{
    image_speed = 0;
    currentFriction = FRICTION;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!global.padDetected)
{
    image_speed = 0;
    currentFriction = FRICTION;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
