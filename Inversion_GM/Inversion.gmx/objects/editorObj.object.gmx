<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* This sets up a level editor. */



currentTile = 0;     //the tile to draw after clicking mouse;
tiles = 0;           //holds all tile constants
tileIndex = 0;
playerOnMap = false; //ensures that only one player tile can be on the screen
levelArray = 0;           //used to iterate through the grid
inverseArray = 0;        //inverted level data.
isInverted = false;      //controls how level is drawn, and affects collision.
global.levelInverted = false;
playerOnLevel = false;      //if true, no other player will be on screen.
exitOnLevel = false;
global.shadowCreated = false;

global.keyTotal = 0;    //# of keys in level.
global.keyCount = 0;    //keys in player's possession.


//array setup
tiles[0] = TILE_BACK;
tiles[1] = TILE_FORE;        //in the inverted world, 0 blocks the player instead of 1
tiles[2] = TILE_PLAYER;
tiles[3] = TILE_EXIT;
tiles[4] = TILE_KEY;


//map setup
global.levelGrid = ds_grid_create(floor(room_width / TILE_SIZE), floor(room_height / TILE_SIZE));
global.invLevelGrid = ds_grid_create(floor(room_width / TILE_SIZE), floor(room_height / TILE_SIZE));


ds_grid_set_region(global.levelGrid, 0, 0, ds_grid_width(global.levelGrid) - 1, ds_grid_height(global.levelGrid) / 2, TILE_BACK);
ds_grid_set_region(global.levelGrid, 0, ds_grid_height(global.levelGrid) / 2, ds_grid_width(global.levelGrid) - 1, ds_grid_height(global.levelGrid) - 1, TILE_FORE);
ds_grid_set_region(global.invLevelGrid, 0, 0, ds_grid_width(global.invLevelGrid) - 1, ds_grid_height(global.invLevelGrid) / 2, TILE_BACK);
ds_grid_set_region(global.invLevelGrid, 0, ds_grid_height(global.invLevelGrid) / 2, ds_grid_width(global.invLevelGrid) - 1, ds_grid_height(global.invLevelGrid) - 1, TILE_FORE);

//draw tiles
if (!global.loadFromFile)
{
    for (var i = 0; i &lt; ds_grid_width(global.levelGrid); i++)
    {
        for (var j = 0; j &lt; ds_grid_height(global.levelGrid); j++)
        {
            if (j &lt; ds_grid_height(global.levelGrid) / 2)
            {
                levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, tile2Obj);
            }
            else
            {
                levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, tile1Obj);
            }
            
        }
    }
}
else    //load from file
{
    for (var i = 0; i &lt; ds_grid_width(global.levelGrid); i++)
    {
        for (var j = 0; j &lt; ds_grid_height(global.levelGrid); j++)
        {
            ds_grid_set(global.levelGrid, i, j, ds_grid_get(global.mapGrid, i, j));
            ds_grid_set(global.invLevelGrid, i, j, ds_grid_get(global.inverseGrid, i, j));
            
            //set the tile array
            switch(ds_grid_get(global.mapGrid, i, j))
            {
                case TILE_FORE:
                    levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, tile1Obj);
                    break;
                    
                case TILE_BACK:
                    levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, tile2Obj);
                    break;
                    
                case TILE_PLAYER:
                    levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, playerObj);
                    //playerOnLevel = true;
                    break;
                    
                case TILE_EXIT:
                    levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, exitObj);
                    break;
                    
                case TILE_KEY:
                    levelArray[i, j] = instance_create(i * TILE_SIZE, j * TILE_SIZE, keyObj);
                    break;
            }
        }
    }
    
    //remove map grid from memory
    if (ds_exists(global.mapGrid, ds_type_grid))
    {
        ds_grid_destroy(global.mapGrid);
        ds_grid_destroy(global.inverseGrid);
        show_debug_message("mapGrid destroyed.");
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//re-calculate the key total.
global.keyTotal = 0;
with(keyObj)
{
    global.keyTotal++;
}

show_debug_message("Key Total: " + string(global.keyTotal));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Place tiles, move screen, save file, etc.</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//place selected tile on screen
if (mouse_check_button(mb_left))
{
    if (!global.levelInverted)    //can only draw on non-inverted level
    {
        var i = floor(mouse_x / TILE_SIZE);
        var j = floor(mouse_y / TILE_SIZE);
        //create tile at clicked location
        ds_grid_set(global.levelGrid, i, j, currentTile);
        show_debug_message("Clicked location " + string(i) + ", " + string(j));
        
        
        /* THIS IS IMPORTANT! anytime a tile is drawn, a tile must be placed in an opposite location in the inverted level! */
        switch(currentTile)
        {
            case TILE_BACK: case TILE_FORE:
                ds_grid_set(global.invLevelGrid, abs(ds_grid_width(global.invLevelGrid) - i - 1), abs(ds_grid_height(global.invLevelGrid) - j - 1), !currentTile);
                break;
                
            case TILE_PLAYER:
                 global.shadowCreated = false;
                 break;
            
            default:
                ds_grid_set(global.invLevelGrid, abs(ds_grid_width(global.invLevelGrid) - i - 1), abs(ds_grid_height(global.invLevelGrid) - j - 1), currentTile);
                break;
                 
        }
        
        /*if (currentTile == TILE_BACK || currentTile == TILE_FORE)
        {
            ds_grid_set(global.invLevelGrid, abs(ds_grid_width(global.invLevelGrid) - i - 1), abs(ds_grid_height(global.invLevelGrid) - j - 1), !currentTile);
        }
        else
        {
            ds_grid_set(global.invLevelGrid, abs(ds_grid_width(global.invLevelGrid) - i - 1), abs(ds_grid_height(global.invLevelGrid) - j - 1), currentTile);
        }
        
        if (currentTile == TILE_PLAYER)
        {
            global.shadowCreated = false;
            
        }*/
      
    }
    
}

//Invert level
if (mouse_check_button_pressed(mb_right))
{
    global.levelInverted = !global.levelInverted;
}

/** Horizontal movement **/
if (keyboard_check_direct(vk_right))
{
    if (view_xview + view_wview &lt;= room_width - 8)
        view_xview += 8;
}

if (keyboard_check_direct(vk_left))
{
    if (view_xview &gt;= 8)
        view_xview -= 8;
}

/** Vertical movement **/
if (keyboard_check_direct(vk_down))
{
    if (view_yview + view_hview &lt;= room_height - 8)
        view_yview += 8;
}

if (keyboard_check_direct(vk_up))
{
    if (view_yview &gt;= 8)
        view_yview -= 8;
}

//Tile select
if (keyboard_check_pressed(vk_space))
{
    if (tileIndex == array_length_1d(tiles) - 1)
    {
        tileIndex = 0;
    }
    else
    {
        tileIndex++;
    }
    currentTile = tiles[tileIndex];
}

//Back to eeditor menu
if (keyboard_check_pressed(vk_escape))
{
    room_goto(editorMenuScreen); 
}

//Save map
if (keyboard_check_pressed(vk_f1))
{
    var file = get_save_filename_ext("Text file|*.txt", "", "", "Save Level");
    
    //if a filename is given, save data
    if (file != "")
    {
        
        var fileName = file_text_open_write(file);
        //write room width &amp; height
        file_text_write_real(fileName, room_width);
        file_text_writeln(fileName);
        file_text_write_real(fileName, room_height);
        file_text_writeln(fileName);
               
        //update all tiles
        for (var i = 0; i &lt; ds_grid_width(global.levelGrid); i++)
        {
            for (var j = 0; j &lt; ds_grid_height(global.levelGrid); j++)
            {
               
               file_text_write_real(fileName, ds_grid_get(global.levelGrid, i, j)); //TODO: figure out how to not have this add an extra space at the end of a line
                
            }
            
            file_text_writeln(fileName);    
        }
        
        file_text_write_string(fileName, "***********");  //lets the editor know to skip this line and start reading the inverted level.
        file_text_writeln(fileName);
        
        //write the inverted level
        for (var i = 0; i &lt; ds_grid_width(global.invLevelGrid); i++)
        {
            for (var j = 0; j &lt; ds_grid_height(global.invLevelGrid); j++)
            {
                file_text_write_real(fileName, ds_grid_get(global.invLevelGrid, i, j)); //TODO: figure out how to not have this add an extra space at the end of a line
            }
            file_text_writeln(fileName);    
        }        
        
        file_text_close(fileName);
        
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//memory clean up
show_debug_message("Removing level grid.");
ds_grid_destroy(global.levelGrid);
ds_grid_destroy(global.invLevelGrid);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//memory clean up
if (ds_exists(global.levelGrid, ds_type_grid))
{
    show_debug_message("Removing level grid.");
    ds_grid_destroy(global.levelGrid);
    ds_grid_destroy(global.invLevelGrid);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* draw editor array data */


draw_set_font(gameFont);
draw_set_color(c_navy);

/*for (var i = 0; i &lt; ds_grid_width(levelGrid); i++)
{
    for (var j = 0; j &lt; ds_grid_height(levelGrid); j++)
    {       
        draw_text(i * TILE_SIZE, j * TILE_SIZE, string(ds_grid_get(levelGrid, i, j)));
    }
}*/


draw_text(0, 0, "ESC - New Map");
draw_text(200, 0, "F1 - Save");
draw_text(350, 0, "Key Total: " + string(global.keyTotal));
draw_text(600, 0, "Space - select a tile");
draw_text(0, 650, "Tile: " + string(currentTile));

if (global.levelInverted)
{
    draw_set_color(c_red);
    draw_text(0, 700, "Inverted - Cannot place tile!");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* The level is drawn differently depending on whether it's inverted or not. */

//tile selection icons


if (!global.levelInverted)
{
    for (var i = 0; i &lt; ds_grid_width(global.levelGrid); i++)
    {
        for (var j = 0; j &lt; ds_grid_height(global.levelGrid); j++)
        {
           
            switch(ds_grid_get(global.levelGrid, i, j))
            {
                 case TILE_FORE:
                    with(levelArray[i, j])
                        instance_change(tile1Obj, 1);
                    break;
                 
                  case TILE_BACK:
                    with(levelArray[i, j])
                        instance_change(tile2Obj, 1);
                    break;
                  
                  case TILE_PLAYER:
                    with(levelArray[i, j])                   
                         instance_change(playerObj, 1);
                    
                    break;
                    
                  case TILE_EXIT:
                    with(levelArray[i, j])
                        instance_change(exitObj, 1);
                    break;
                    
                   case TILE_KEY:
                    with(levelArray[i, j])                   
                         instance_change(keyObj, 1);
                    break;
            }
           
        }
    }
}
else
{
    for (var i = 0; i &lt; ds_grid_width(global.invLevelGrid); i++)
    {
        for (var j = 0; j &lt; ds_grid_height(global.invLevelGrid); j++)
        {
           
            switch(ds_grid_get(global.invLevelGrid, i, j))
            {
                 case TILE_FORE:
                    with(levelArray[ds_grid_width(global.invLevelGrid) - 1 - i, j])
                        instance_change(tile2Obj, 1);
                    break;
                 
                  case TILE_BACK:
                    with(levelArray[ds_grid_width(global.invLevelGrid) - 1 - i, j])
                        instance_change(tile1Obj, 1);
                    break;
                  
                  case TILE_PLAYER:
                    with(levelArray[ds_grid_width(global.invLevelGrid) - 1 - i, ds_grid_height(global.invLevelGrid) - 1 - j])  //this is so the mirror is placed in the same position as player.
                        instance_change(playerObj, 1);
                    break;
                  
                  case TILE_EXIT:
                    with(levelArray[ds_grid_width(global.invLevelGrid) - 1 - i, j])
                        instance_change(exitObj, 1);
                    break;
                    
                  case TILE_KEY:
                    with(levelArray[ds_grid_width(global.invLevelGrid) - 1 - i, j])
                        instance_change(keyObj, 1);
                    break;
            }
           
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
