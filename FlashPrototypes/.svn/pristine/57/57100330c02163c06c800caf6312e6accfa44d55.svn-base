/* Home Run is a game where you must fill up a meter within the time limit by mashing buttons
as quickly as you can.  Once time is up, a ball is struck and sent flying. Its distance
depends on the power meter. */

package  
{
	import flash.display.MovieClip;
	import flash.events.KeyboardEvent;
	import flash.ui.Keyboard;
	import flash.events.Event;
	import flash.display.DisplayObject;
	import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;
	import flash.text.TextField;
	import flash.text.TextFormat;
	
	
	public class Main extends MovieClip
	{
		//timer variables
		var _timer:Clock;
		var _timerText:TextField;
		var _timerFormat:TextFormat;
		var _secs:uint = 10;	//clock time
				
		//var _player:Shape;
		var _ball:Shape;		//the object that'll go flying
		/*var _emptyBar:Shape;	
		var _powerBar:Shape;	*/
		//var _ground:Shape;		//ball should bounce off of this
		
		
		var _pBarWidth:Number = 0;	//increases as buttons are pressed, decreases otherwise
		
		//physics
		const GRAVITY:Number = 0.4;
		const FRICTION:Number = 0.95;
		var _frictionLevel:Number;
		var _ballVelocityX:Number = 0;
		var _ballVelocityY:Number = 0;
		var _ballKicked:Boolean = false; //if true, ball is airborne
		
		//graphics
		var _player:Player = new Player();
		var _sky:Sky = new Sky();
		var _skyCopy:Sky = new Sky();
		var _emptyMeter:EmptyMeter = new EmptyMeter();
		var _powerMeter:PowerMeter = new PowerMeter();	//fills up as you mash buttons
		var _ground1:Ground1 = new Ground1();
		var _ground1Copy:Ground1 = new Ground1();
		
		var _ground2:Ground2 = new Ground2();
		var _ground2Copy:Ground2 = new Ground2();
		
		var _ground3:Ground3 = new Ground3();
		var _ground3Copy:Ground3 = new Ground3();
		
		var _ground4:Ground4 = new Ground4();
		var _ground4Copy:Ground4 = new Ground4();
		
		
		//HUD text
		var _instructionText:TextField;	//tells player what must be done
		var _barLabel:TextField;		//gauge label
		var _timeLabel:TextField;		//timer label

		public function Main() 
		{
			//timer information
			_timer = new Clock(_secs);
			
			_timerFormat = new TextFormat();
			_timerFormat.size = 50;
			_timerFormat.bold = true;
			_timerFormat.font = "Calibri";
			
			_timerText = new TextField();
			_timerText.defaultTextFormat = _timerFormat;
			_timerText.textColor = 0x0000F0;
			_timerText.width = 160;
			_timerText.height = 80;
			_timerText.x = 450;
			_timerText.y = 200;
			
			//display time and append zeroes where necessary
			if (_timer.Seconds() < 10)
			{
				_timerText.text = _timer.Minutes() + ":0" + _timer.Seconds() + ":" + _timer.Milliseconds();
			}
			else
			{
				_timerText.text = _timer.Minutes() + ":" + _timer.Seconds() + ":" + _timer.Milliseconds();
			}
			
						
			//instruction
			_instructionText = new TextField();

			_instructionText.textColor = 0x000000;
			_instructionText.defaultTextFormat = _timerFormat;
			_instructionText.x = 100;
			_instructionText.y = 50;
			_instructionText.width = 800;
			_instructionText.height = 150;
			_instructionText.multiline = true;
			_instructionText.wordWrap = true;
			_instructionText.text = "Mash the A and D keys to gather power!";
			
			//player
			_player.x = 100;
			_player.y = 500;
			
			//gauge
			_powerMeter.x = 55;
			_powerMeter.y = 665;
			_powerMeter.width = 0;
			
			//empty power gauge
			_emptyMeter.x = 50;
			_emptyMeter.y = 660;
			
			
			//ball
			_ball = new Shape();
			_ball.graphics.beginFill(0xcccccc);
			_ball.graphics.drawCircle(0, 0, 20);
			_ball.x = 180;
			_ball.y = 570;
			_ball.graphics.endFill();
			
			//set up the sky for scrolling
			_sky.x = 0;
			_skyCopy.x = Number(stage.stageWidth) - 10.3;
			
			//set up ground
			_ground1.x = 0;
			_ground1.y = 589;
			_ground1Copy.x = Number(stage.stageWidth);
			_ground1Copy.y = 589;
			
			_ground2.x = 0;
			_ground2.y = 459;
			_ground2Copy.x = Number(stage.stageWidth);
			_ground2Copy.y = 459;
			
			_ground3.x = 0;
			_ground3.y = 365;
			_ground3Copy.x = Number(stage.stageWidth);
			_ground3Copy.y = 365;
			
			_ground4.x = 0;
			_ground4.y = 297;
			_ground4Copy.x = Number(stage.stageWidth);
			_ground4Copy.y = 297;
			
			//power gauge label
			_barLabel = new TextField();
			_barLabel.defaultTextFormat = _timerFormat;
			_barLabel.text = "POWER";
			_barLabel.textColor = 0x004400;
			_barLabel.x = 40;
			_barLabel.y = 600;
			_barLabel.width = 200;
			_barLabel.height = 70;
			

			//add everything
			addChild(_sky);
			addChild(_skyCopy);
			
			addChild (_ground1);
			addChild(_ground1Copy);
			
			addChild (_ground2);
			addChild(_ground2Copy);
			
			addChild (_ground3);
			addChild(_ground3Copy);
			
			addChild(_ground4);
			addChild(_ground4Copy);
			
			addChild(_timerText);
			addChild(_instructionText);
			addChild(_barLabel);
			
			
			addChild(_emptyMeter);
			addChild(_powerMeter);
			
			
			addChild(_ball);
			addChild(_player);
			
			
			
			addEventListener(Event.ENTER_FRAME, onEnterFrame);
			stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);
		}
		
		public function onKeyUp(event:KeyboardEvent):void
		{
			/*when the A or D keys are pressed, the power gauge fills up slowly. The gauge 
			decreases if nothing is pressed.*/
			
			switch (event.keyCode)
			{
				case Keyboard.A: case Keyboard.D:
				if (!_timer.TimeUp())
				{
					_pBarWidth += 1.3;
					if (_pBarWidth > 200)
					{
						_pBarWidth = 200;
					}
				}
					//trace ("Gauge: " + _pBarWidth);
			}
		}
		
		function onEnterFrame(event:Event):void
		{
			//update the sky
			ScrollImage(_sky, _skyCopy, -0.3);
			
			/* The ground scrolls at different speeds to create depth. */
			ScrollImage(_ground1, _ground1Copy, -1);
			ScrollImage(_ground2, _ground2Copy, -0.7);
			ScrollImage(_ground3, _ground3Copy, -0.4);
			ScrollImage(_ground4, _ground4Copy, -0.1);
			
			//the power gauge continually decreases
			if (!_timer.TimeUp())
			{
				_pBarWidth -= 0.1;
				if (_pBarWidth < 0)
				{
					_pBarWidth = 0;
				}
			}
			
			//update power gauge
			_powerMeter.width = _pBarWidth;
			//trace("Power: " + _pBarWidth);
			
			/* Time continually decreases until it reaches 0 or player completes all words. */
			_timer.Countdown();
			
						
						
			//update the timer
			if (_timer.Seconds() < 10 && _timer.Milliseconds() < 10)
			{
				_timerText.text = _timer.Minutes() + ":0" + _timer.Seconds() + ":0" + _timer.Milliseconds();
			}
			else if (_timer.Seconds() < 10 && _timer.Milliseconds() > 10)
			{
				_timerText.text = _timer.Minutes() + ":0" + _timer.Seconds() + ":" + _timer.Milliseconds();
			}
			else if (_timer.Seconds() > 10 && _timer.Milliseconds() < 10)
			{
				_timerText.text = _timer.Minutes() + ":" + _timer.Seconds() + ":0" + _timer.Milliseconds();
			}
			else
			{
				_timerText.text = _timer.Minutes() + ":" + _timer.Seconds() + ":" + _timer.Milliseconds();
			}
			
			/* When the timer reaches 0, the ball is struck and sent flying. Calculate how far the ball
			goes based on the power */
			if (_timer.TimeUp() && !_ballKicked)
			{
				//send the ball flying. The ball will slow down as _pBarWidth decreases each frame.
				_ballVelocityX = _pBarWidth * 0.50;
				_ballVelocityY = -(_pBarWidth * 0.35);
				_ballKicked = true;
			}
			
			
			//apply physics
			_ballVelocityY += GRAVITY;
			if (_ballVelocityY > 50)
			{
				_ballVelocityY = 50;
			}
			
			_ball.x += _ballVelocityX;
			_ball.y += _ballVelocityY;
			
			trace ("Ball Velocity Y: " + _ballVelocityY);
			
			if (_ball.y > _ground1.y)
			{
				_ball.y = _ground1.y;
				
				//apply friction
				_frictionLevel = FRICTION;
				
			}
			else
			{
				_frictionLevel = 1;
			}
			
			_ballVelocityX *= _frictionLevel;
			
			if (_ball.x > stage.stageWidth)
			{
				_ball.x = 0;
			}
			
			if (_ball.y < 0)
			{
				_ball.y = 0;
			}
		}
		
		//infinitely scrolls an image and its copy at a specified rate
		function ScrollImage(image1:DisplayObject, image2:DisplayObject, rate:Number):void
		{
			
			image1.x += rate;
			image2.x += rate;
			
			/*I check to see if x is less than the negative value of the stage width because
			the origin is at 0. The moment the left side of the sky touches the screen edge,
			the sky flips to the opposite end, leaving empty space. */
			
			if (image1.x < -stage.stageWidth)
			{
				image1.x = Number(stage.stageWidth) + rate;
			}
			
			if (image2.x < -stage.stageWidth)
			{
				image2.x = Number(stage.stageWidth) + rate;
			}
			
			
		}

	}
	
}
